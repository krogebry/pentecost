#!/usr/bin/env ruby
##
# Pentecost
require "rubygems"
require "pp"
require "json"
require "thor"
require "base64"
require "logger"
require "openssl"
require "rest-client"
require "aws-sdk-core"
require "highline/import"



FS_ROOT = File.expand_path(File.join(File.dirname(__FILE__), ".."))
require File.join( FS_ROOT, "/lib/pentecost" )
require File.join( FS_ROOT, "/lib/version" )

Log = Logger.new( STDOUT )
Log.level = Logger::DEBUG

class Pentecost::Cli < Thor
  package_name "Pentecost"
  map "-L" => :list
  map "-v" => :version
        
  desc "version", "Version"
  def version()
    puts Pentecost::VERSION
  end
  
  desc "pop QUEUE_NAME", "Pop a queue."
  def pop( queue_name )
    Aws.config = { 
      access_key_id:  ENV["AWS_ACCESS_KEY"],
      secret_access_key:  ENV["AWS_SECRET_KEY"]
    }
    Log.debug( "Queue name: %s" % queue_name )

    ["us-east-1"].each do |region_name|
      sqs = Aws::SQS.new({ region: region_name })
      url = sqs.get_queue_url({ queue_name: "opsauto" }).queue_url
      attrs = sqs.get_queue_attributes({ queue_url: url, attribute_names: ["All"] })
      #Log.debug( "Num: %i" % attrs.attributes["ApproximateNumberOfMessages"] )
      num_messages = attrs.attributes["ApproximateNumberOfMessages"].to_i
      #Log.debug( "Num messages: %i" % num_messages )
      num_messages.times do |i|
        sqs.receive_message({ queue_url: url }).messages.each do |msg|
          #pp msg
          #Log.debug( "Message: %s" % msg.body )
          params = {}
          msg.body.split( "\n" ).each do |line|
            (key,val) = line.split( "=" )
            params[key] = val[1,val.length-2]
          end
          pp params
          begin
            json = JSON::parse( params["ResourceProperties"] )
            Log.debug( "%s\t%s" % [params["LogicalResourceId"], params["ResourceStatus"]] )


          rescue => e
            Log.debug( "Caught exception: %s" % e )

          ensure
            sqs.delete_message({ 
              queue_url: url,
              receipt_handle: msg.receipt_handle 
            })

          end
          #sleep 1
        end
      end
    end
  end

  desc "compile INPUT_FILE_NAME OUTPUT_FILE_NAME", "Compile a template"
  def compile(input_file_name, output_file_name)
    if(!File.exists?( input_file_name ))
      Log.fatal( "File does not exist: %s" % input_file_name )
    end
    source_json = JSON::parse(File.read( input_file_name ))
    compiler = Pentecost::Compiler.new( source_json )
    compiler.compile()
  end

  desc "launch INPUT_FILE_NAME", "Launch a template"
  def launch(input_file_name)
    if(!File.exists?( input_file_name ))
      Log.fatal( "File does not exist: %s" % input_file_name )
    end

    #params = JSON::parse(File.read( params_file_name ))
    template = JSON::parse(File.read( input_file_name ))
    region_name = "us-east-1"

    Aws.config = { 
      region: region_name,
      access_key_id:  ENV["AWS_ACCESS_KEY"],
      secret_access_key:  ENV["AWS_SECRET_KEY"]
    }
    Aws.add_plugin( Aws::Plugins::CloudFormationMerge )

    cfn = Aws::CloudFormation.new()

    stack_name = "ops"
    deployment_name = "Pent0"
    deployment_stack_name = "%s-%s" % [deployment_name, stack_name]

    #params = { :parameters => {} }
    #params[:parameters][""] = stack_name
    #params[:parameters]["DeploymentName"] = deployment_name
    #params[:parameters]["AWSAccountName"] = self.deployment.aws_account_name

    #params = {
      #"Parameters.member.1.ParameterKey" => "AvailabilityZone",
      #"Parameters.member.1.ParameterValue" => "us-east-1"
    #}

    #params = { :parameters => [{ "AvailabilityZone" => "us-east-1" }]}
    params = [{ :parameter_key => "AvailabilityZone", :parameter_value => "us-east-1" }]
    #params = [{ "AvailabilityZone" => "us-east-1" }]

    pp params

    cfn.create_stack({
      tags: [{ key: "Name", value: "Test0" }],
      on_failure: "DO_NOTHING",
      parameters: params,
      stack_name: stack_name,
      template_body: template.to_json
    })
  end
end

Pentecost::Cli.start( ARGV )
